# README

- 2차년도 무선 엣지 영상보안시스템 기술 개발
- 무선 엣지 CCTV 개발 및 엣지 AI 보안지능 최적화 및 보안 단말 연계협업
- 엣지간 클러스터링 및 AI 배포, 단말간 협업 기능 개발





### Daily report

---



#### 0905

- Perl basic 파일을 keti 폴더에 생성 후 공부 



#### 0906

- 개인 일정 정리(약속 줄이기)
- Perl basic 채우기
- 현금영수증 체크



#### 0908

- [고가용성 k8s 클러스터](https://computing-jhson.tistory.com/108) - 1개의 서버에서 여러개의 마스터 활용(리서치)

  - 고가용성(HA, High Availability)라는 말이 생소할 수 있는데 가용성이 높다, 즉 높은 확률로 사용할 수 있다는 말이다. 애플리케이션 서비스를 생각해보자. 이 서비스의 DB가 고장난다면 더 이상 애플리케이션을 사용할 수 없다. 이런 저런 방법으로 DB가 절대 고장나지 않도록 한다면 더이상 DB에 의해 서비스 이용이 불가능해지는 상황이 사라질 것이다. 즉 이 서비스는 높은 확률로 사용가능한(고장나지 않는), 고가용성을 가지는 것이다.

  - 이중화(Dual-Master) 또는 다중 마스터(Multi-Master) 구성을 사용

  - loadbalancer 가 3개의 마스터노드에 한개의 IP로 접근 가능하게하고 일을 배분하는데 우리 과제에서는 필요없을듯?

  - Kubernetes (K8s)에서 9개의 워커 노드를 3개씩 나누어 1개 서버에서 운용되는 3개의 마스터 노드와 연결해 3개의 클러스터를 만드는 것은 가능합니다. 이를 위해서는 다음과 같은 절차를 따를 수 있습니다.

    1. **하드웨어 또는 가상 머신 설정**:

       - 각 클러스터의 마스터 노드를 실행할 서버를 설정합니다. 이 서버는 높은 가용성을 제공하기 위해 3개의 독립적인 마스터 노드를 호스팅해야 합니다.
       - 나머지 9개의 워커 노드를 3개씩 그룹화하여 클러스터 별로 구성합니다.

    2. **Kubernetes 설치**:

       - 각 마스터 노드에서 Kubernetes를 설치하고 초기화합니다. `kubeadm`을 사용하면 쉽게 초기화할 수 있습니다.

       - 마스터 노드의 

         ```
         kubeadm
         ```

          초기화 명령은 다음과 유사할 것입니다.

         ```
         bashCopy code
         kubeadm init --control-plane-endpoint <마스터 노드 로드 밸런서 주소>:<포트> --upload-certs
         ```

    3. **마스터 노드 연결**:

       - 각 마스터 노드를 마스터 노드 로드 밸런서 뒤에 배치합니다. 이 로드 밸런서는 3개의 마스터 노드로부터 요청을 분산합니다. 이로써 고가용성을 확보할 수 있습니다.
       - 마스터 노드 간에는 적절한 네트워크 연결이 설정되어야 합니다.

    4. **워커 노드 추가**:

       - 각 클러스터에 속한 워커 노드를 설정하고 마스터 노드에 추가합니다.
       - 각 클러스터에는 고유한 API 서버 엔드포인트가 있어야 하며, 각 마스터 노드의 kubelet을 해당 클러스터의 API 서버로 가리켜야 합니다.
       - 즉, 워커 노드는 해당 클러스터의 마스터 노드와 통신하게 됩니다.

    5. **클러스터 관리**:

       - 각 클러스터는 독립적으로 운영되므로, 각 마스터 노드에서 해당 클러스터의 상태를 관리합니다.
       - `kubectl` 명령을 사용하여 각 클러스터에 대한 작업을 수행합니다.

    6. **네트워크 구성**:

       - 각 클러스터의 노드 간 통신을 위해 적절한 네트워크 구성을 수행해야 합니다. 네트워크 플러그인 (예: Calico, Flannel, Weave)을 사용하여 파드 간 통신을 활성화합니다.

    이렇게 하면 1개 서버에서 3개의 독립적인 Kubernetes 클러스터를 운영할 수 있습니다. 각 클러스터는 자체적으로 관리되며, 마스터 노드는 고가용성을 제공합니다. 그러나 이러한 구성은 관리 복잡성을 높일 수 있으므로 주의해야 합니다. 또한 서버 리소스, 네트워크 설정, 보안 등 다양한 요인을 고려해야 합니다.

- [마스터노드에서 애플리케이션 실행](https://m.blog.naver.com/isc0304/221890427898)

  - 권장하지 않지만 가능
  - `$ kubectl taint nodes --all node-role.kubernetes.io/master- node/master untainted`

- 쿠버네티스 사용치 않고 배포, 삭제 자동화

  - SW 배포 및 삭제를 자동화하기 위해 다음과 같이 구성할 수 있는 일반적인 방법을 제안해 드립니다. 이러한 구성은 대규모 시스템에서 유용하며, 여러 서버 그룹에 대한 일괄 작업을 수행하는 데 도움이 될 것입니다.

    1. **구성 관리 도구 선택**: SW 배포와 삭제를 자동화하려면 구성 관리 도구를 선택해야 합니다. 대표적인 도구로는 Ansible, Puppet, Chef, 또는 Terraform과 같은 인프라스트럭처 관리 도구가 있습니다. 이 중 어떤 도구를 사용할 것인지 선택하십시오.

    2. **서버 그룹 정의**: 서버 그룹을 정의하고, 각 그룹에 배포할 서버들을 명시적으로 식별합니다. 예를 들어, 그룹 A, B, C로 나눌 수 있습니다.

    3. **SW 패키지 준비**: 배포할 소프트웨어 패키지를 준비하고, 이를 배포할 서버에 복사합니다.

    4. **Playbook 또는 Manifest 작성**: Ansible의 경우, Playbook을 작성하거나, Puppet 또는 Chef의 경우 Manifest를 작성하여 배포 및 삭제 작업을 정의합니다. 이러한 스크립트는 각 그룹에 대한 특정 작업을 수행합니다.

    5. **인벤토리 관리**: Ansible을 사용하는 경우, 인벤토리 파일에 각 서버의 호스트명 또는 IP 주소를 관리합니다. 이렇게 하면 어떤 서버에 작업을 수행할 것인지 명확하게 식별할 수 있습니다.

    6. **배포 및 삭제 작업 실행**: 선택한 구성 관리 도구를 사용하여 배포 및 삭제 작업을 실행합니다. 예를 들어, Ansible을 사용한다면 다음과 같은 명령으로 Playbook을 실행할 수 있습니다.

       ```
       cssCopy code
       ansible-playbook -i inventory.ini deploy.yml
       ```

       `deploy.yml`은 배포 작업을 정의한 Playbook 파일입니다. 삭제 작업을 수행하려면 삭제에 해당하는 다른 Playbook 또는 Manifest를 실행하면 됩니다.

    7. **스케줄링 및 모니터링**: 배포 및 삭제 작업을 자동화하기 위해 스케줄러 또는 CI/CD 파이프라인과 통합할 수 있습니다. 또한 작업의 진행 상황과 결과를 모니터링하고 로깅하여 문제가 발생할 경우 신속하게 대응할 수 있습니다.

    8. **보안 및 권한 관리**: 서버에 접근하고 수정하는 권한을 엄격하게 관리해야 합니다. SSH 키 또는 인증서를 사용하여 보안을 강화하고, 작업에 필요한 권한만 부여해야 합니다.

    9. **백업 및 롤백 전략**: 배포 작업을 수행하기 전에 중요한 데이터와 설정을 백업하는 전략을 마련하고, 필요한 경우 롤백을 수행할 수 있는 방법을 고려해야 합니다.

    이러한 구성을 통해 SW 배포 및 삭제를 효율적으로 자동화하고, 시스템 관리 작업을 간소화할 수 있습니다. 선택한 도구와 환경에 따라 세부적인 설정 및 스크립트 작성이 필요할 수 있습니다.



#### 0922

- 1년차 app.py 확인 및 올해 내용 적용